/* eslint-disable no-nested-ternary */
/**
 * Generated by orval
 * Do not edit manually.
 * Beautify Baltics Core API
 * Beautify Baltics Core API for back-office operations
 * OpenAPI spec version: v1
 */
import type {
  DataTag,
  DefinedInitialDataOptions,
  DefinedUseInfiniteQueryResult,
  DefinedUseQueryResult,
  InfiniteData,
  MutationFunction,
  QueryClient,
  QueryFunction,
  QueryKey,
  UndefinedInitialDataOptions,
  UseInfiniteQueryOptions,
  UseInfiniteQueryResult,
  UseMutationOptions,
  UseMutationResult,
  UseQueryOptions,
  UseQueryResult,
  UseSuspenseQueryOptions,
  UseSuspenseQueryResult,
} from '@tanstack/react-query';
import {
  useInfiniteQuery,
  useMutation,
  useQuery,
  useSuspenseQuery,
} from '@tanstack/react-query';

import { customClient } from '../mutator/custom-client';

import type {
  CancelBookingRequest,
  CancelBookingResponse,
  ConfirmBookingRequest,
  ConfirmBookingResponse,
  CreateBookingRequest,
  CreateBookingResponse,
  FindBookingsParams,
  FindBookingsResponsePagedResponse,
  GetBookingByIdParams,
  GetBookingByIdResponse,
  ProblemDetails,
  RescheduleBookingRequest,
  RescheduleBookingResponse,
  ValidationProblemDetails,
} from './api.schemas';

/**
 * @summary Find bookings
 */
export const findBookings = (
  params?: FindBookingsParams,
  signal?: AbortSignal,
) => customClient<FindBookingsResponsePagedResponse>(
  {
    url: '/api/v1/bookings',
    method: 'GET',
    params,
    signal,
  },
);

export const getFindBookingsQueryKey = (params?: FindBookingsParams) => ['/api/v1/bookings', ...(params ? [params] : [])] as const;

export const getFindBookingsInfiniteQueryOptions = <TData = InfiniteData<Awaited<ReturnType<typeof findBookings>>, FindBookingsParams['page']>, TError = ValidationProblemDetails>(params?: FindBookingsParams, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof findBookings>>, TError, TData, QueryKey, FindBookingsParams['page']>>, },
) => {
  const { query: queryOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getFindBookingsQueryKey(params);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof findBookings>>, QueryKey, FindBookingsParams['page']> = ({ signal, pageParam }) => findBookings({ ...params, page: pageParam || params?.page }, signal);

  return { queryKey, queryFn, ...queryOptions } as UseInfiniteQueryOptions<Awaited<ReturnType<typeof findBookings>>, TError, TData, QueryKey, FindBookingsParams['page']> & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type FindBookingsInfiniteQueryResult = NonNullable<Awaited<ReturnType<typeof findBookings>>>;
export type FindBookingsInfiniteQueryError = ValidationProblemDetails;

export function useFindBookingsInfinite<TData = InfiniteData<Awaited<ReturnType<typeof findBookings>>, FindBookingsParams['page']>, TError = ValidationProblemDetails>(
  params: undefined | FindBookingsParams, options: { query:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof findBookings>>, TError, TData, QueryKey, FindBookingsParams['page']>> & Pick<
  DefinedInitialDataOptions<
  Awaited<ReturnType<typeof findBookings>>,
  TError,
  Awaited<ReturnType<typeof findBookings>>, QueryKey
  >, 'initialData'
  >, }
  , queryClient?: QueryClient
): DefinedUseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useFindBookingsInfinite<TData = InfiniteData<Awaited<ReturnType<typeof findBookings>>, FindBookingsParams['page']>, TError = ValidationProblemDetails>(
  params?: FindBookingsParams, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof findBookings>>, TError, TData, QueryKey, FindBookingsParams['page']>> & Pick<
  UndefinedInitialDataOptions<
  Awaited<ReturnType<typeof findBookings>>,
  TError,
  Awaited<ReturnType<typeof findBookings>>, QueryKey
  >, 'initialData'
  >, }
  , queryClient?: QueryClient
): UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useFindBookingsInfinite<TData = InfiniteData<Awaited<ReturnType<typeof findBookings>>, FindBookingsParams['page']>, TError = ValidationProblemDetails>(
  params?: FindBookingsParams, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof findBookings>>, TError, TData, QueryKey, FindBookingsParams['page']>>, }
  , queryClient?: QueryClient
): UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
/**
 * @summary Find bookings
 */

export function useFindBookingsInfinite<TData = InfiniteData<Awaited<ReturnType<typeof findBookings>>, FindBookingsParams['page']>, TError = ValidationProblemDetails>(
  params?: FindBookingsParams,
  options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof findBookings>>, TError, TData, QueryKey, FindBookingsParams['page']>>, },
  queryClient?: QueryClient,
): UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {
  const queryOptions = getFindBookingsInfiniteQueryOptions(params, options);

  const query = useInfiniteQuery(queryOptions, queryClient) as UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

export const getFindBookingsQueryOptions = <TData = Awaited<ReturnType<typeof findBookings>>, TError = ValidationProblemDetails>(params?: FindBookingsParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof findBookings>>, TError, TData>>, },
) => {
  const { query: queryOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getFindBookingsQueryKey(params);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof findBookings>>> = ({ signal }) => findBookings(params, signal);

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<Awaited<ReturnType<typeof findBookings>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type FindBookingsQueryResult = NonNullable<Awaited<ReturnType<typeof findBookings>>>;
export type FindBookingsQueryError = ValidationProblemDetails;

export function useFindBookings<TData = Awaited<ReturnType<typeof findBookings>>, TError = ValidationProblemDetails>(
  params: undefined | FindBookingsParams, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof findBookings>>, TError, TData>> & Pick<
  DefinedInitialDataOptions<
  Awaited<ReturnType<typeof findBookings>>,
  TError,
  Awaited<ReturnType<typeof findBookings>>
  >, 'initialData'
  >, }
  , queryClient?: QueryClient
): DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useFindBookings<TData = Awaited<ReturnType<typeof findBookings>>, TError = ValidationProblemDetails>(
  params?: FindBookingsParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof findBookings>>, TError, TData>> & Pick<
  UndefinedInitialDataOptions<
  Awaited<ReturnType<typeof findBookings>>,
  TError,
  Awaited<ReturnType<typeof findBookings>>
  >, 'initialData'
  >, }
  , queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useFindBookings<TData = Awaited<ReturnType<typeof findBookings>>, TError = ValidationProblemDetails>(
  params?: FindBookingsParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof findBookings>>, TError, TData>>, }
  , queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
/**
 * @summary Find bookings
 */

export function useFindBookings<TData = Awaited<ReturnType<typeof findBookings>>, TError = ValidationProblemDetails>(
  params?: FindBookingsParams,
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof findBookings>>, TError, TData>>, },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {
  const queryOptions = getFindBookingsQueryOptions(params, options);

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

export const getFindBookingsSuspenseQueryOptions = <TData = Awaited<ReturnType<typeof findBookings>>, TError = ValidationProblemDetails>(params?: FindBookingsParams, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof findBookings>>, TError, TData>>, },
) => {
  const { query: queryOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getFindBookingsQueryKey(params);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof findBookings>>> = ({ signal }) => findBookings(params, signal);

  return { queryKey, queryFn, ...queryOptions } as UseSuspenseQueryOptions<Awaited<ReturnType<typeof findBookings>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type FindBookingsSuspenseQueryResult = NonNullable<Awaited<ReturnType<typeof findBookings>>>;
export type FindBookingsSuspenseQueryError = ValidationProblemDetails;

export function useFindBookingsSuspense<TData = Awaited<ReturnType<typeof findBookings>>, TError = ValidationProblemDetails>(
  params: undefined | FindBookingsParams, options: { query:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof findBookings>>, TError, TData>>, }
  , queryClient?: QueryClient
): UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useFindBookingsSuspense<TData = Awaited<ReturnType<typeof findBookings>>, TError = ValidationProblemDetails>(
  params?: FindBookingsParams, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof findBookings>>, TError, TData>>, }
  , queryClient?: QueryClient
): UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useFindBookingsSuspense<TData = Awaited<ReturnType<typeof findBookings>>, TError = ValidationProblemDetails>(
  params?: FindBookingsParams, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof findBookings>>, TError, TData>>, }
  , queryClient?: QueryClient
): UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
/**
 * @summary Find bookings
 */

export function useFindBookingsSuspense<TData = Awaited<ReturnType<typeof findBookings>>, TError = ValidationProblemDetails>(
  params?: FindBookingsParams,
  options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof findBookings>>, TError, TData>>, },
  queryClient?: QueryClient,
): UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {
  const queryOptions = getFindBookingsSuspenseQueryOptions(params, options);

  const query = useSuspenseQuery(queryOptions, queryClient) as UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * @summary Create booking
 */
export const createBooking = (
  createBookingRequest: CreateBookingRequest,
  signal?: AbortSignal,
) => customClient<CreateBookingResponse>(
  {
    url: '/api/v1/bookings',
    method: 'POST',
    headers: { 'Content-Type': 'application/json' },
    data: createBookingRequest,
    signal,
  },
);

export const getCreateBookingMutationOptions = <TError = ProblemDetails | ValidationProblemDetails,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof createBooking>>, TError, { data: CreateBookingRequest }, TContext>, },
  ): UseMutationOptions<Awaited<ReturnType<typeof createBooking>>, TError, { data: CreateBookingRequest }, TContext> => {
  const mutationKey = ['createBooking'];
  const { mutation: mutationOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } };

  const mutationFn: MutationFunction<Awaited<ReturnType<typeof createBooking>>, { data: CreateBookingRequest }> = (props) => {
    const { data } = props ?? {};

    return createBooking(data);
  };

  return { mutationFn, ...mutationOptions };
};

export type CreateBookingMutationResult = NonNullable<Awaited<ReturnType<typeof createBooking>>>;
export type CreateBookingMutationBody = CreateBookingRequest;
export type CreateBookingMutationError = ProblemDetails | ValidationProblemDetails;

/**
 * @summary Create booking
 */
export const useCreateBooking = <TError = ProblemDetails | ValidationProblemDetails,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof createBooking>>, TError, { data: CreateBookingRequest }, TContext>, },
    queryClient?: QueryClient): UseMutationResult<
  Awaited<ReturnType<typeof createBooking>>,
  TError,
  { data: CreateBookingRequest },
  TContext
  > => {
  const mutationOptions = getCreateBookingMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};
/**
 * @summary Get booking by id
 */
export const getBookingById = (
  id: string,
  params: GetBookingByIdParams,
  signal?: AbortSignal,
) => customClient<GetBookingByIdResponse>(
  {
    url: `/api/v1/bookings/${id}`,
    method: 'GET',
    params,
    signal,
  },
);

export const getGetBookingByIdQueryKey = (
  id?: string,
  params?: GetBookingByIdParams,
) => [`/api/v1/bookings/${id}`, ...(params ? [params] : [])] as const;

export const getGetBookingByIdQueryOptions = <TData = Awaited<ReturnType<typeof getBookingById>>, TError = ProblemDetails>(id: string,
  params: GetBookingByIdParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getBookingById>>, TError, TData>>, },
) => {
  const { query: queryOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetBookingByIdQueryKey(id, params);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getBookingById>>> = ({ signal }) => getBookingById(id, params, signal);

  return {
    queryKey, queryFn, enabled: !!(id), ...queryOptions,
  } as UseQueryOptions<Awaited<ReturnType<typeof getBookingById>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type GetBookingByIdQueryResult = NonNullable<Awaited<ReturnType<typeof getBookingById>>>;
export type GetBookingByIdQueryError = ProblemDetails;

export function useGetBookingById<TData = Awaited<ReturnType<typeof getBookingById>>, TError = ProblemDetails>(
  id: string,
  params: GetBookingByIdParams, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getBookingById>>, TError, TData>> & Pick<
  DefinedInitialDataOptions<
  Awaited<ReturnType<typeof getBookingById>>,
  TError,
  Awaited<ReturnType<typeof getBookingById>>
  >, 'initialData'
  >, }
  , queryClient?: QueryClient
): DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useGetBookingById<TData = Awaited<ReturnType<typeof getBookingById>>, TError = ProblemDetails>(
  id: string,
  params: GetBookingByIdParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getBookingById>>, TError, TData>> & Pick<
  UndefinedInitialDataOptions<
  Awaited<ReturnType<typeof getBookingById>>,
  TError,
  Awaited<ReturnType<typeof getBookingById>>
  >, 'initialData'
  >, }
  , queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useGetBookingById<TData = Awaited<ReturnType<typeof getBookingById>>, TError = ProblemDetails>(
  id: string,
  params: GetBookingByIdParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getBookingById>>, TError, TData>>, }
  , queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
/**
 * @summary Get booking by id
 */

export function useGetBookingById<TData = Awaited<ReturnType<typeof getBookingById>>, TError = ProblemDetails>(
  id: string,
  params: GetBookingByIdParams,
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getBookingById>>, TError, TData>>, },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {
  const queryOptions = getGetBookingByIdQueryOptions(id, params, options);

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

export const getGetBookingByIdSuspenseQueryOptions = <TData = Awaited<ReturnType<typeof getBookingById>>, TError = ProblemDetails>(id: string,
  params: GetBookingByIdParams, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getBookingById>>, TError, TData>>, },
) => {
  const { query: queryOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetBookingByIdQueryKey(id, params);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getBookingById>>> = ({ signal }) => getBookingById(id, params, signal);

  return { queryKey, queryFn, ...queryOptions } as UseSuspenseQueryOptions<Awaited<ReturnType<typeof getBookingById>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type GetBookingByIdSuspenseQueryResult = NonNullable<Awaited<ReturnType<typeof getBookingById>>>;
export type GetBookingByIdSuspenseQueryError = ProblemDetails;

export function useGetBookingByIdSuspense<TData = Awaited<ReturnType<typeof getBookingById>>, TError = ProblemDetails>(
  id: string,
  params: GetBookingByIdParams, options: { query:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getBookingById>>, TError, TData>>, }
  , queryClient?: QueryClient
): UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useGetBookingByIdSuspense<TData = Awaited<ReturnType<typeof getBookingById>>, TError = ProblemDetails>(
  id: string,
  params: GetBookingByIdParams, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getBookingById>>, TError, TData>>, }
  , queryClient?: QueryClient
): UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useGetBookingByIdSuspense<TData = Awaited<ReturnType<typeof getBookingById>>, TError = ProblemDetails>(
  id: string,
  params: GetBookingByIdParams, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getBookingById>>, TError, TData>>, }
  , queryClient?: QueryClient
): UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
/**
 * @summary Get booking by id
 */

export function useGetBookingByIdSuspense<TData = Awaited<ReturnType<typeof getBookingById>>, TError = ProblemDetails>(
  id: string,
  params: GetBookingByIdParams,
  options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getBookingById>>, TError, TData>>, },
  queryClient?: QueryClient,
): UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {
  const queryOptions = getGetBookingByIdSuspenseQueryOptions(id, params, options);

  const query = useSuspenseQuery(queryOptions, queryClient) as UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * @summary Reschedule booking
 */
export const postApiV1BookingsIdReschedule = (
  id: string,
  rescheduleBookingRequest: RescheduleBookingRequest,
  signal?: AbortSignal,
) => customClient<RescheduleBookingResponse>(
  {
    url: `/api/v1/bookings/${id}/reschedule`,
    method: 'POST',
    headers: { 'Content-Type': 'application/json' },
    data: rescheduleBookingRequest,
    signal,
  },
);

export const getPostApiV1BookingsIdRescheduleMutationOptions = <TError = ProblemDetails | ProblemDetails | ValidationProblemDetails,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof postApiV1BookingsIdReschedule>>, TError, { id: string;data: RescheduleBookingRequest }, TContext>, },
  ): UseMutationOptions<Awaited<ReturnType<typeof postApiV1BookingsIdReschedule>>, TError, { id: string;data: RescheduleBookingRequest }, TContext> => {
  const mutationKey = ['postApiV1BookingsIdReschedule'];
  const { mutation: mutationOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } };

  const mutationFn: MutationFunction<Awaited<ReturnType<typeof postApiV1BookingsIdReschedule>>, { id: string;data: RescheduleBookingRequest }> = (props) => {
    const { id, data } = props ?? {};

    return postApiV1BookingsIdReschedule(id, data);
  };

  return { mutationFn, ...mutationOptions };
};

export type PostApiV1BookingsIdRescheduleMutationResult = NonNullable<Awaited<ReturnType<typeof postApiV1BookingsIdReschedule>>>;
export type PostApiV1BookingsIdRescheduleMutationBody = RescheduleBookingRequest;
export type PostApiV1BookingsIdRescheduleMutationError = ProblemDetails | ProblemDetails | ValidationProblemDetails;

/**
 * @summary Reschedule booking
 */
export const usePostApiV1BookingsIdReschedule = <TError = ProblemDetails | ProblemDetails | ValidationProblemDetails,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof postApiV1BookingsIdReschedule>>, TError, { id: string;data: RescheduleBookingRequest }, TContext>, },
    queryClient?: QueryClient): UseMutationResult<
  Awaited<ReturnType<typeof postApiV1BookingsIdReschedule>>,
  TError,
  { id: string;data: RescheduleBookingRequest },
  TContext
  > => {
  const mutationOptions = getPostApiV1BookingsIdRescheduleMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};
/**
 * Booking can be cancelled by either the master or the client.
Booking cannot be cancelled if it's less than 24 hours before the scheduled time.
 * @summary Cancel booking
 */
export const cancelBooking = (
  id: string,
  cancelBookingRequest: CancelBookingRequest,
  signal?: AbortSignal,
) => customClient<CancelBookingResponse>(
  {
    url: `/api/v1/bookings/${id}/cancel`,
    method: 'POST',
    headers: { 'Content-Type': 'application/json' },
    data: cancelBookingRequest,
    signal,
  },
);

export const getCancelBookingMutationOptions = <TError = ProblemDetails | ProblemDetails | ValidationProblemDetails,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof cancelBooking>>, TError, { id: string;data: CancelBookingRequest }, TContext>, },
  ): UseMutationOptions<Awaited<ReturnType<typeof cancelBooking>>, TError, { id: string;data: CancelBookingRequest }, TContext> => {
  const mutationKey = ['cancelBooking'];
  const { mutation: mutationOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } };

  const mutationFn: MutationFunction<Awaited<ReturnType<typeof cancelBooking>>, { id: string;data: CancelBookingRequest }> = (props) => {
    const { id, data } = props ?? {};

    return cancelBooking(id, data);
  };

  return { mutationFn, ...mutationOptions };
};

export type CancelBookingMutationResult = NonNullable<Awaited<ReturnType<typeof cancelBooking>>>;
export type CancelBookingMutationBody = CancelBookingRequest;
export type CancelBookingMutationError = ProblemDetails | ProblemDetails | ValidationProblemDetails;

/**
 * @summary Cancel booking
 */
export const useCancelBooking = <TError = ProblemDetails | ProblemDetails | ValidationProblemDetails,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof cancelBooking>>, TError, { id: string;data: CancelBookingRequest }, TContext>, },
    queryClient?: QueryClient): UseMutationResult<
  Awaited<ReturnType<typeof cancelBooking>>,
  TError,
  { id: string;data: CancelBookingRequest },
  TContext
  > => {
  const mutationOptions = getCancelBookingMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};
/**
 * Only the master can confirm a booking.
 * @summary Confirm booking
 */
export const confirmBooking = (
  id: string,
  confirmBookingRequest: ConfirmBookingRequest,
  signal?: AbortSignal,
) => customClient<ConfirmBookingResponse>(
  {
    url: `/api/v1/bookings/${id}/confirm`,
    method: 'POST',
    headers: { 'Content-Type': 'application/json' },
    data: confirmBookingRequest,
    signal,
  },
);

export const getConfirmBookingMutationOptions = <TError = ProblemDetails | ProblemDetails | ValidationProblemDetails,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof confirmBooking>>, TError, { id: string;data: ConfirmBookingRequest }, TContext>, },
  ): UseMutationOptions<Awaited<ReturnType<typeof confirmBooking>>, TError, { id: string;data: ConfirmBookingRequest }, TContext> => {
  const mutationKey = ['confirmBooking'];
  const { mutation: mutationOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } };

  const mutationFn: MutationFunction<Awaited<ReturnType<typeof confirmBooking>>, { id: string;data: ConfirmBookingRequest }> = (props) => {
    const { id, data } = props ?? {};

    return confirmBooking(id, data);
  };

  return { mutationFn, ...mutationOptions };
};

export type ConfirmBookingMutationResult = NonNullable<Awaited<ReturnType<typeof confirmBooking>>>;
export type ConfirmBookingMutationBody = ConfirmBookingRequest;
export type ConfirmBookingMutationError = ProblemDetails | ProblemDetails | ValidationProblemDetails;

/**
 * @summary Confirm booking
 */
export const useConfirmBooking = <TError = ProblemDetails | ProblemDetails | ValidationProblemDetails,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof confirmBooking>>, TError, { id: string;data: ConfirmBookingRequest }, TContext>, },
    queryClient?: QueryClient): UseMutationResult<
  Awaited<ReturnType<typeof confirmBooking>>,
  TError,
  { id: string;data: ConfirmBookingRequest },
  TContext
  > => {
  const mutationOptions = getConfirmBookingMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};
