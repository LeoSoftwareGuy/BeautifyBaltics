/* eslint-disable no-nested-ternary */
/**
 * Generated by orval
 * Do not edit manually.
 * Beautify Baltics Core API
 * Beautify Baltics Core API for back-office operations
 * OpenAPI spec version: v1
 */
import type {
  DataTag,
  DefinedInitialDataOptions,
  DefinedUseInfiniteQueryResult,
  DefinedUseQueryResult,
  InfiniteData,
  MutationFunction,
  QueryClient,
  QueryFunction,
  QueryKey,
  UndefinedInitialDataOptions,
  UseInfiniteQueryOptions,
  UseInfiniteQueryResult,
  UseMutationOptions,
  UseMutationResult,
  UseQueryOptions,
  UseQueryResult,
  UseSuspenseQueryOptions,
  UseSuspenseQueryResult,
} from '@tanstack/react-query';
import {
  useInfiniteQuery,
  useMutation,
  useQuery,
  useSuspenseQuery,
} from '@tanstack/react-query';

import { customClient } from '../mutator/custom-client';

import type {
  CreateMasterAvailabilityRequest,
  CreateMasterAvailabilityResponse,
  CreateMasterJobRequest,
  CreateMasterJobResponse,
  CreateMasterRequest,
  CreateMasterResponse,
  FindMastersParams,
  FindMastersResponsePagedResponse,
  GetMasterByIdParams,
  GetMasterByIdResponse,
  ProblemDetails,
  UpdateMasterProfileRequest,
  UpdateMasterProfileResponse,
  ValidationProblemDetails,
} from './api.schemas';

/**
 * @summary Find masters
 */
export const findMasters = (
  params?: FindMastersParams,
  signal?: AbortSignal,
) => customClient<FindMastersResponsePagedResponse>(
  {
    url: '/api/v1/masters',
    method: 'GET',
    params,
    signal,
  },
);

export const getFindMastersQueryKey = (params?: FindMastersParams) => ['/api/v1/masters', ...(params ? [params] : [])] as const;

export const getFindMastersInfiniteQueryOptions = <TData = InfiniteData<Awaited<ReturnType<typeof findMasters>>, FindMastersParams['page']>, TError = ValidationProblemDetails>(params?: FindMastersParams, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof findMasters>>, TError, TData, QueryKey, FindMastersParams['page']>>, },
) => {
  const { query: queryOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getFindMastersQueryKey(params);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof findMasters>>, QueryKey, FindMastersParams['page']> = ({ signal, pageParam }) => findMasters({ ...params, page: pageParam || params?.page }, signal);

  return { queryKey, queryFn, ...queryOptions } as UseInfiniteQueryOptions<Awaited<ReturnType<typeof findMasters>>, TError, TData, QueryKey, FindMastersParams['page']> & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type FindMastersInfiniteQueryResult = NonNullable<Awaited<ReturnType<typeof findMasters>>>;
export type FindMastersInfiniteQueryError = ValidationProblemDetails;

export function useFindMastersInfinite<TData = InfiniteData<Awaited<ReturnType<typeof findMasters>>, FindMastersParams['page']>, TError = ValidationProblemDetails>(
  params: undefined | FindMastersParams, options: { query:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof findMasters>>, TError, TData, QueryKey, FindMastersParams['page']>> & Pick<
  DefinedInitialDataOptions<
  Awaited<ReturnType<typeof findMasters>>,
  TError,
  Awaited<ReturnType<typeof findMasters>>, QueryKey
  >, 'initialData'
  >, }
  , queryClient?: QueryClient
): DefinedUseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useFindMastersInfinite<TData = InfiniteData<Awaited<ReturnType<typeof findMasters>>, FindMastersParams['page']>, TError = ValidationProblemDetails>(
  params?: FindMastersParams, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof findMasters>>, TError, TData, QueryKey, FindMastersParams['page']>> & Pick<
  UndefinedInitialDataOptions<
  Awaited<ReturnType<typeof findMasters>>,
  TError,
  Awaited<ReturnType<typeof findMasters>>, QueryKey
  >, 'initialData'
  >, }
  , queryClient?: QueryClient
): UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useFindMastersInfinite<TData = InfiniteData<Awaited<ReturnType<typeof findMasters>>, FindMastersParams['page']>, TError = ValidationProblemDetails>(
  params?: FindMastersParams, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof findMasters>>, TError, TData, QueryKey, FindMastersParams['page']>>, }
  , queryClient?: QueryClient
): UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
/**
 * @summary Find masters
 */

export function useFindMastersInfinite<TData = InfiniteData<Awaited<ReturnType<typeof findMasters>>, FindMastersParams['page']>, TError = ValidationProblemDetails>(
  params?: FindMastersParams,
  options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof findMasters>>, TError, TData, QueryKey, FindMastersParams['page']>>, },
  queryClient?: QueryClient,
): UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {
  const queryOptions = getFindMastersInfiniteQueryOptions(params, options);

  const query = useInfiniteQuery(queryOptions, queryClient) as UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

export const getFindMastersQueryOptions = <TData = Awaited<ReturnType<typeof findMasters>>, TError = ValidationProblemDetails>(params?: FindMastersParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof findMasters>>, TError, TData>>, },
) => {
  const { query: queryOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getFindMastersQueryKey(params);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof findMasters>>> = ({ signal }) => findMasters(params, signal);

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<Awaited<ReturnType<typeof findMasters>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type FindMastersQueryResult = NonNullable<Awaited<ReturnType<typeof findMasters>>>;
export type FindMastersQueryError = ValidationProblemDetails;

export function useFindMasters<TData = Awaited<ReturnType<typeof findMasters>>, TError = ValidationProblemDetails>(
  params: undefined | FindMastersParams, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof findMasters>>, TError, TData>> & Pick<
  DefinedInitialDataOptions<
  Awaited<ReturnType<typeof findMasters>>,
  TError,
  Awaited<ReturnType<typeof findMasters>>
  >, 'initialData'
  >, }
  , queryClient?: QueryClient
): DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useFindMasters<TData = Awaited<ReturnType<typeof findMasters>>, TError = ValidationProblemDetails>(
  params?: FindMastersParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof findMasters>>, TError, TData>> & Pick<
  UndefinedInitialDataOptions<
  Awaited<ReturnType<typeof findMasters>>,
  TError,
  Awaited<ReturnType<typeof findMasters>>
  >, 'initialData'
  >, }
  , queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useFindMasters<TData = Awaited<ReturnType<typeof findMasters>>, TError = ValidationProblemDetails>(
  params?: FindMastersParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof findMasters>>, TError, TData>>, }
  , queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
/**
 * @summary Find masters
 */

export function useFindMasters<TData = Awaited<ReturnType<typeof findMasters>>, TError = ValidationProblemDetails>(
  params?: FindMastersParams,
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof findMasters>>, TError, TData>>, },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {
  const queryOptions = getFindMastersQueryOptions(params, options);

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

export const getFindMastersSuspenseQueryOptions = <TData = Awaited<ReturnType<typeof findMasters>>, TError = ValidationProblemDetails>(params?: FindMastersParams, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof findMasters>>, TError, TData>>, },
) => {
  const { query: queryOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getFindMastersQueryKey(params);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof findMasters>>> = ({ signal }) => findMasters(params, signal);

  return { queryKey, queryFn, ...queryOptions } as UseSuspenseQueryOptions<Awaited<ReturnType<typeof findMasters>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type FindMastersSuspenseQueryResult = NonNullable<Awaited<ReturnType<typeof findMasters>>>;
export type FindMastersSuspenseQueryError = ValidationProblemDetails;

export function useFindMastersSuspense<TData = Awaited<ReturnType<typeof findMasters>>, TError = ValidationProblemDetails>(
  params: undefined | FindMastersParams, options: { query:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof findMasters>>, TError, TData>>, }
  , queryClient?: QueryClient
): UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useFindMastersSuspense<TData = Awaited<ReturnType<typeof findMasters>>, TError = ValidationProblemDetails>(
  params?: FindMastersParams, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof findMasters>>, TError, TData>>, }
  , queryClient?: QueryClient
): UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useFindMastersSuspense<TData = Awaited<ReturnType<typeof findMasters>>, TError = ValidationProblemDetails>(
  params?: FindMastersParams, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof findMasters>>, TError, TData>>, }
  , queryClient?: QueryClient
): UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
/**
 * @summary Find masters
 */

export function useFindMastersSuspense<TData = Awaited<ReturnType<typeof findMasters>>, TError = ValidationProblemDetails>(
  params?: FindMastersParams,
  options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof findMasters>>, TError, TData>>, },
  queryClient?: QueryClient,
): UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {
  const queryOptions = getFindMastersSuspenseQueryOptions(params, options);

  const query = useSuspenseQuery(queryOptions, queryClient) as UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * @summary Create master
 */
export const createMaster = (
  createMasterRequest: CreateMasterRequest,
  signal?: AbortSignal,
) => customClient<CreateMasterResponse>(
  {
    url: '/api/v1/masters',
    method: 'POST',
    headers: { 'Content-Type': 'application/json' },
    data: createMasterRequest,
    signal,
  },
);

export const getCreateMasterMutationOptions = <TError = ValidationProblemDetails,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof createMaster>>, TError, { data: CreateMasterRequest }, TContext>, },
  ): UseMutationOptions<Awaited<ReturnType<typeof createMaster>>, TError, { data: CreateMasterRequest }, TContext> => {
  const mutationKey = ['createMaster'];
  const { mutation: mutationOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } };

  const mutationFn: MutationFunction<Awaited<ReturnType<typeof createMaster>>, { data: CreateMasterRequest }> = (props) => {
    const { data } = props ?? {};

    return createMaster(data);
  };

  return { mutationFn, ...mutationOptions };
};

export type CreateMasterMutationResult = NonNullable<Awaited<ReturnType<typeof createMaster>>>;
export type CreateMasterMutationBody = CreateMasterRequest;
export type CreateMasterMutationError = ValidationProblemDetails;

/**
 * @summary Create master
 */
export const useCreateMaster = <TError = ValidationProblemDetails,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof createMaster>>, TError, { data: CreateMasterRequest }, TContext>, },
    queryClient?: QueryClient): UseMutationResult<
  Awaited<ReturnType<typeof createMaster>>,
  TError,
  { data: CreateMasterRequest },
  TContext
  > => {
  const mutationOptions = getCreateMasterMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};
/**
 * @summary Get master by id
 */
export const getMasterById = (
  id: string,
  params: GetMasterByIdParams,
  signal?: AbortSignal,
) => customClient<GetMasterByIdResponse>(
  {
    url: `/api/v1/masters/${id}`,
    method: 'GET',
    params,
    signal,
  },
);

export const getGetMasterByIdQueryKey = (
  id?: string,
  params?: GetMasterByIdParams,
) => [`/api/v1/masters/${id}`, ...(params ? [params] : [])] as const;

export const getGetMasterByIdQueryOptions = <TData = Awaited<ReturnType<typeof getMasterById>>, TError = ProblemDetails>(id: string,
  params: GetMasterByIdParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getMasterById>>, TError, TData>>, },
) => {
  const { query: queryOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetMasterByIdQueryKey(id, params);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getMasterById>>> = ({ signal }) => getMasterById(id, params, signal);

  return {
    queryKey, queryFn, enabled: !!(id), ...queryOptions,
  } as UseQueryOptions<Awaited<ReturnType<typeof getMasterById>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type GetMasterByIdQueryResult = NonNullable<Awaited<ReturnType<typeof getMasterById>>>;
export type GetMasterByIdQueryError = ProblemDetails;

export function useGetMasterById<TData = Awaited<ReturnType<typeof getMasterById>>, TError = ProblemDetails>(
  id: string,
  params: GetMasterByIdParams, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getMasterById>>, TError, TData>> & Pick<
  DefinedInitialDataOptions<
  Awaited<ReturnType<typeof getMasterById>>,
  TError,
  Awaited<ReturnType<typeof getMasterById>>
  >, 'initialData'
  >, }
  , queryClient?: QueryClient
): DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useGetMasterById<TData = Awaited<ReturnType<typeof getMasterById>>, TError = ProblemDetails>(
  id: string,
  params: GetMasterByIdParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getMasterById>>, TError, TData>> & Pick<
  UndefinedInitialDataOptions<
  Awaited<ReturnType<typeof getMasterById>>,
  TError,
  Awaited<ReturnType<typeof getMasterById>>
  >, 'initialData'
  >, }
  , queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useGetMasterById<TData = Awaited<ReturnType<typeof getMasterById>>, TError = ProblemDetails>(
  id: string,
  params: GetMasterByIdParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getMasterById>>, TError, TData>>, }
  , queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
/**
 * @summary Get master by id
 */

export function useGetMasterById<TData = Awaited<ReturnType<typeof getMasterById>>, TError = ProblemDetails>(
  id: string,
  params: GetMasterByIdParams,
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getMasterById>>, TError, TData>>, },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {
  const queryOptions = getGetMasterByIdQueryOptions(id, params, options);

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

export const getGetMasterByIdSuspenseQueryOptions = <TData = Awaited<ReturnType<typeof getMasterById>>, TError = ProblemDetails>(id: string,
  params: GetMasterByIdParams, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getMasterById>>, TError, TData>>, },
) => {
  const { query: queryOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetMasterByIdQueryKey(id, params);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getMasterById>>> = ({ signal }) => getMasterById(id, params, signal);

  return { queryKey, queryFn, ...queryOptions } as UseSuspenseQueryOptions<Awaited<ReturnType<typeof getMasterById>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type GetMasterByIdSuspenseQueryResult = NonNullable<Awaited<ReturnType<typeof getMasterById>>>;
export type GetMasterByIdSuspenseQueryError = ProblemDetails;

export function useGetMasterByIdSuspense<TData = Awaited<ReturnType<typeof getMasterById>>, TError = ProblemDetails>(
  id: string,
  params: GetMasterByIdParams, options: { query:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getMasterById>>, TError, TData>>, }
  , queryClient?: QueryClient
): UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useGetMasterByIdSuspense<TData = Awaited<ReturnType<typeof getMasterById>>, TError = ProblemDetails>(
  id: string,
  params: GetMasterByIdParams, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getMasterById>>, TError, TData>>, }
  , queryClient?: QueryClient
): UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useGetMasterByIdSuspense<TData = Awaited<ReturnType<typeof getMasterById>>, TError = ProblemDetails>(
  id: string,
  params: GetMasterByIdParams, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getMasterById>>, TError, TData>>, }
  , queryClient?: QueryClient
): UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
/**
 * @summary Get master by id
 */

export function useGetMasterByIdSuspense<TData = Awaited<ReturnType<typeof getMasterById>>, TError = ProblemDetails>(
  id: string,
  params: GetMasterByIdParams,
  options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getMasterById>>, TError, TData>>, },
  queryClient?: QueryClient,
): UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {
  const queryOptions = getGetMasterByIdSuspenseQueryOptions(id, params, options);

  const query = useSuspenseQuery(queryOptions, queryClient) as UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * @summary Update master profile
 */
export const updateMasterProfile = (
  id: string,
  updateMasterProfileRequest: UpdateMasterProfileRequest,
) => customClient<UpdateMasterProfileResponse>(
  {
    url: `/api/v1/masters/${id}`,
    method: 'PUT',
    headers: { 'Content-Type': 'application/json' },
    data: updateMasterProfileRequest,
  },
);

export const getUpdateMasterProfileMutationOptions = <TError = ProblemDetails | ValidationProblemDetails,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof updateMasterProfile>>, TError, { id: string;data: UpdateMasterProfileRequest }, TContext>, },
  ): UseMutationOptions<Awaited<ReturnType<typeof updateMasterProfile>>, TError, { id: string;data: UpdateMasterProfileRequest }, TContext> => {
  const mutationKey = ['updateMasterProfile'];
  const { mutation: mutationOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } };

  const mutationFn: MutationFunction<Awaited<ReturnType<typeof updateMasterProfile>>, { id: string;data: UpdateMasterProfileRequest }> = (props) => {
    const { id, data } = props ?? {};

    return updateMasterProfile(id, data);
  };

  return { mutationFn, ...mutationOptions };
};

export type UpdateMasterProfileMutationResult = NonNullable<Awaited<ReturnType<typeof updateMasterProfile>>>;
export type UpdateMasterProfileMutationBody = UpdateMasterProfileRequest;
export type UpdateMasterProfileMutationError = ProblemDetails | ValidationProblemDetails;

/**
 * @summary Update master profile
 */
export const useUpdateMasterProfile = <TError = ProblemDetails | ValidationProblemDetails,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof updateMasterProfile>>, TError, { id: string;data: UpdateMasterProfileRequest }, TContext>, },
    queryClient?: QueryClient): UseMutationResult<
  Awaited<ReturnType<typeof updateMasterProfile>>,
  TError,
  { id: string;data: UpdateMasterProfileRequest },
  TContext
  > => {
  const mutationOptions = getUpdateMasterProfileMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};
/**
 * @summary Add job to a master
 */
export const createMasterJob = (
  id: string,
  createMasterJobRequest: CreateMasterJobRequest,
  signal?: AbortSignal,
) => customClient<CreateMasterJobResponse>(
  {
    url: `/api/v1/masters/${id}/jobs`,
    method: 'POST',
    headers: { 'Content-Type': 'application/json' },
    data: createMasterJobRequest,
    signal,
  },
);

export const getCreateMasterJobMutationOptions = <TError = ProblemDetails | ValidationProblemDetails,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof createMasterJob>>, TError, { id: string;data: CreateMasterJobRequest }, TContext>, },
  ): UseMutationOptions<Awaited<ReturnType<typeof createMasterJob>>, TError, { id: string;data: CreateMasterJobRequest }, TContext> => {
  const mutationKey = ['createMasterJob'];
  const { mutation: mutationOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } };

  const mutationFn: MutationFunction<Awaited<ReturnType<typeof createMasterJob>>, { id: string;data: CreateMasterJobRequest }> = (props) => {
    const { id, data } = props ?? {};

    return createMasterJob(id, data);
  };

  return { mutationFn, ...mutationOptions };
};

export type CreateMasterJobMutationResult = NonNullable<Awaited<ReturnType<typeof createMasterJob>>>;
export type CreateMasterJobMutationBody = CreateMasterJobRequest;
export type CreateMasterJobMutationError = ProblemDetails | ValidationProblemDetails;

/**
 * @summary Add job to a master
 */
export const useCreateMasterJob = <TError = ProblemDetails | ValidationProblemDetails,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof createMasterJob>>, TError, { id: string;data: CreateMasterJobRequest }, TContext>, },
    queryClient?: QueryClient): UseMutationResult<
  Awaited<ReturnType<typeof createMasterJob>>,
  TError,
  { id: string;data: CreateMasterJobRequest },
  TContext
  > => {
  const mutationOptions = getCreateMasterJobMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};
/**
 * @summary Define master availability slots
 */
export const createMasterAvailability = (
  id: string,
  createMasterAvailabilityRequest: CreateMasterAvailabilityRequest,
  signal?: AbortSignal,
) => customClient<CreateMasterAvailabilityResponse>(
  {
    url: `/api/v1/masters/${id}/availability`,
    method: 'POST',
    headers: { 'Content-Type': 'application/json' },
    data: createMasterAvailabilityRequest,
    signal,
  },
);

export const getCreateMasterAvailabilityMutationOptions = <TError = ProblemDetails | ValidationProblemDetails,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof createMasterAvailability>>, TError, { id: string;data: CreateMasterAvailabilityRequest }, TContext>, },
  ): UseMutationOptions<Awaited<ReturnType<typeof createMasterAvailability>>, TError, { id: string;data: CreateMasterAvailabilityRequest }, TContext> => {
  const mutationKey = ['createMasterAvailability'];
  const { mutation: mutationOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } };

  const mutationFn: MutationFunction<Awaited<ReturnType<typeof createMasterAvailability>>, { id: string;data: CreateMasterAvailabilityRequest }> = (props) => {
    const { id, data } = props ?? {};

    return createMasterAvailability(id, data);
  };

  return { mutationFn, ...mutationOptions };
};

export type CreateMasterAvailabilityMutationResult = NonNullable<Awaited<ReturnType<typeof createMasterAvailability>>>;
export type CreateMasterAvailabilityMutationBody = CreateMasterAvailabilityRequest;
export type CreateMasterAvailabilityMutationError = ProblemDetails | ValidationProblemDetails;

/**
 * @summary Define master availability slots
 */
export const useCreateMasterAvailability = <TError = ProblemDetails | ValidationProblemDetails,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof createMasterAvailability>>, TError, { id: string;data: CreateMasterAvailabilityRequest }, TContext>, },
    queryClient?: QueryClient): UseMutationResult<
  Awaited<ReturnType<typeof createMasterAvailability>>,
  TError,
  { id: string;data: CreateMasterAvailabilityRequest },
  TContext
  > => {
  const mutationOptions = getCreateMasterAvailabilityMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};
