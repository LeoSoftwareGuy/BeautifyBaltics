/* eslint-disable no-nested-ternary */
/**
 * Generated by orval
 * Do not edit manually.
 * Beautify Baltics Core API
 * Beautify Baltics Core API for back-office operations
 * OpenAPI spec version: v1
 */
import type {
  DataTag,
  DefinedInitialDataOptions,
  DefinedUseInfiniteQueryResult,
  DefinedUseQueryResult,
  InfiniteData,
  MutationFunction,
  QueryClient,
  QueryFunction,
  QueryKey,
  UndefinedInitialDataOptions,
  UseInfiniteQueryOptions,
  UseInfiniteQueryResult,
  UseMutationOptions,
  UseMutationResult,
  UseQueryOptions,
  UseQueryResult,
  UseSuspenseQueryOptions,
  UseSuspenseQueryResult,
} from '@tanstack/react-query';
import {
  useInfiniteQuery,
  useMutation,
  useQuery,
  useSuspenseQuery,
} from '@tanstack/react-query';

import { customClient } from '../mutator/custom-client';

import type {
  CreateRatingRequest,
  CreateRatingResponse,
  FindMasterRatingsResponsePagedResponse,
  FindRatingsParams,
  GetMasterRatingsParams,
  GetMasterRatingsResponsePagedResponse,
  ProblemDetails,
  ValidationProblemDetails,
} from './api.schemas';

/**
 * Only clients can Create ratings for their completed bookings.
Each booking can only be rated once.
 * @summary Create a rating for a completed booking
 */
export const createRating = (
  createRatingRequest: CreateRatingRequest,
  signal?: AbortSignal,
) => customClient<CreateRatingResponse>(
  {
    url: '/api/v1/ratings',
    method: 'POST',
    headers: { 'Content-Type': 'application/json' },
    data: createRatingRequest,
    signal,
  },
);

export const getCreateRatingMutationOptions = <TError = ProblemDetails | ProblemDetails | ValidationProblemDetails,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof createRating>>, TError, { data: CreateRatingRequest }, TContext>, },
  ): UseMutationOptions<Awaited<ReturnType<typeof createRating>>, TError, { data: CreateRatingRequest }, TContext> => {
  const mutationKey = ['createRating'];
  const { mutation: mutationOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } };

  const mutationFn: MutationFunction<Awaited<ReturnType<typeof createRating>>, { data: CreateRatingRequest }> = (props) => {
    const { data } = props ?? {};

    return createRating(data);
  };

  return { mutationFn, ...mutationOptions };
};

export type CreateRatingMutationResult = NonNullable<Awaited<ReturnType<typeof createRating>>>;
export type CreateRatingMutationBody = CreateRatingRequest;
export type CreateRatingMutationError = ProblemDetails | ProblemDetails | ValidationProblemDetails;

/**
 * @summary Create a rating for a completed booking
 */
export const useCreateRating = <TError = ProblemDetails | ProblemDetails | ValidationProblemDetails,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof createRating>>, TError, { data: CreateRatingRequest }, TContext>, },
    queryClient?: QueryClient): UseMutationResult<
  Awaited<ReturnType<typeof createRating>>,
  TError,
  { data: CreateRatingRequest },
  TContext
  > => {
  const mutationOptions = getCreateRatingMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};
/**
 * @summary Find ratings
 */
export const findRatings = (
  params?: FindRatingsParams,
  signal?: AbortSignal,
) => customClient<FindMasterRatingsResponsePagedResponse>(
  {
    url: '/api/v1/ratings',
    method: 'GET',
    params,
    signal,
  },
);

export const getFindRatingsQueryKey = (params?: FindRatingsParams) => ['/api/v1/ratings', ...(params ? [params] : [])] as const;

export const getFindRatingsInfiniteQueryOptions = <TData = InfiniteData<Awaited<ReturnType<typeof findRatings>>, FindRatingsParams['page']>, TError = ValidationProblemDetails>(params?: FindRatingsParams, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof findRatings>>, TError, TData, QueryKey, FindRatingsParams['page']>>, },
) => {
  const { query: queryOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getFindRatingsQueryKey(params);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof findRatings>>, QueryKey, FindRatingsParams['page']> = ({ signal, pageParam }) => findRatings({ ...params, page: pageParam || params?.page }, signal);

  return { queryKey, queryFn, ...queryOptions } as UseInfiniteQueryOptions<Awaited<ReturnType<typeof findRatings>>, TError, TData, QueryKey, FindRatingsParams['page']> & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type FindRatingsInfiniteQueryResult = NonNullable<Awaited<ReturnType<typeof findRatings>>>;
export type FindRatingsInfiniteQueryError = ValidationProblemDetails;

export function useFindRatingsInfinite<TData = InfiniteData<Awaited<ReturnType<typeof findRatings>>, FindRatingsParams['page']>, TError = ValidationProblemDetails>(
  params: undefined | FindRatingsParams, options: { query:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof findRatings>>, TError, TData, QueryKey, FindRatingsParams['page']>> & Pick<
  DefinedInitialDataOptions<
  Awaited<ReturnType<typeof findRatings>>,
  TError,
  Awaited<ReturnType<typeof findRatings>>, QueryKey
  >, 'initialData'
  >, }
  , queryClient?: QueryClient
): DefinedUseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useFindRatingsInfinite<TData = InfiniteData<Awaited<ReturnType<typeof findRatings>>, FindRatingsParams['page']>, TError = ValidationProblemDetails>(
  params?: FindRatingsParams, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof findRatings>>, TError, TData, QueryKey, FindRatingsParams['page']>> & Pick<
  UndefinedInitialDataOptions<
  Awaited<ReturnType<typeof findRatings>>,
  TError,
  Awaited<ReturnType<typeof findRatings>>, QueryKey
  >, 'initialData'
  >, }
  , queryClient?: QueryClient
): UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useFindRatingsInfinite<TData = InfiniteData<Awaited<ReturnType<typeof findRatings>>, FindRatingsParams['page']>, TError = ValidationProblemDetails>(
  params?: FindRatingsParams, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof findRatings>>, TError, TData, QueryKey, FindRatingsParams['page']>>, }
  , queryClient?: QueryClient
): UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
/**
 * @summary Find ratings
 */

export function useFindRatingsInfinite<TData = InfiniteData<Awaited<ReturnType<typeof findRatings>>, FindRatingsParams['page']>, TError = ValidationProblemDetails>(
  params?: FindRatingsParams,
  options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof findRatings>>, TError, TData, QueryKey, FindRatingsParams['page']>>, },
  queryClient?: QueryClient,
): UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {
  const queryOptions = getFindRatingsInfiniteQueryOptions(params, options);

  const query = useInfiniteQuery(queryOptions, queryClient) as UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

export const getFindRatingsQueryOptions = <TData = Awaited<ReturnType<typeof findRatings>>, TError = ValidationProblemDetails>(params?: FindRatingsParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof findRatings>>, TError, TData>>, },
) => {
  const { query: queryOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getFindRatingsQueryKey(params);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof findRatings>>> = ({ signal }) => findRatings(params, signal);

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<Awaited<ReturnType<typeof findRatings>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type FindRatingsQueryResult = NonNullable<Awaited<ReturnType<typeof findRatings>>>;
export type FindRatingsQueryError = ValidationProblemDetails;

export function useFindRatings<TData = Awaited<ReturnType<typeof findRatings>>, TError = ValidationProblemDetails>(
  params: undefined | FindRatingsParams, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof findRatings>>, TError, TData>> & Pick<
  DefinedInitialDataOptions<
  Awaited<ReturnType<typeof findRatings>>,
  TError,
  Awaited<ReturnType<typeof findRatings>>
  >, 'initialData'
  >, }
  , queryClient?: QueryClient
): DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useFindRatings<TData = Awaited<ReturnType<typeof findRatings>>, TError = ValidationProblemDetails>(
  params?: FindRatingsParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof findRatings>>, TError, TData>> & Pick<
  UndefinedInitialDataOptions<
  Awaited<ReturnType<typeof findRatings>>,
  TError,
  Awaited<ReturnType<typeof findRatings>>
  >, 'initialData'
  >, }
  , queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useFindRatings<TData = Awaited<ReturnType<typeof findRatings>>, TError = ValidationProblemDetails>(
  params?: FindRatingsParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof findRatings>>, TError, TData>>, }
  , queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
/**
 * @summary Find ratings
 */

export function useFindRatings<TData = Awaited<ReturnType<typeof findRatings>>, TError = ValidationProblemDetails>(
  params?: FindRatingsParams,
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof findRatings>>, TError, TData>>, },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {
  const queryOptions = getFindRatingsQueryOptions(params, options);

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

export const getFindRatingsSuspenseQueryOptions = <TData = Awaited<ReturnType<typeof findRatings>>, TError = ValidationProblemDetails>(params?: FindRatingsParams, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof findRatings>>, TError, TData>>, },
) => {
  const { query: queryOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getFindRatingsQueryKey(params);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof findRatings>>> = ({ signal }) => findRatings(params, signal);

  return { queryKey, queryFn, ...queryOptions } as UseSuspenseQueryOptions<Awaited<ReturnType<typeof findRatings>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type FindRatingsSuspenseQueryResult = NonNullable<Awaited<ReturnType<typeof findRatings>>>;
export type FindRatingsSuspenseQueryError = ValidationProblemDetails;

export function useFindRatingsSuspense<TData = Awaited<ReturnType<typeof findRatings>>, TError = ValidationProblemDetails>(
  params: undefined | FindRatingsParams, options: { query:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof findRatings>>, TError, TData>>, }
  , queryClient?: QueryClient
): UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useFindRatingsSuspense<TData = Awaited<ReturnType<typeof findRatings>>, TError = ValidationProblemDetails>(
  params?: FindRatingsParams, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof findRatings>>, TError, TData>>, }
  , queryClient?: QueryClient
): UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useFindRatingsSuspense<TData = Awaited<ReturnType<typeof findRatings>>, TError = ValidationProblemDetails>(
  params?: FindRatingsParams, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof findRatings>>, TError, TData>>, }
  , queryClient?: QueryClient
): UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
/**
 * @summary Find ratings
 */

export function useFindRatingsSuspense<TData = Awaited<ReturnType<typeof findRatings>>, TError = ValidationProblemDetails>(
  params?: FindRatingsParams,
  options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof findRatings>>, TError, TData>>, },
  queryClient?: QueryClient,
): UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {
  const queryOptions = getFindRatingsSuspenseQueryOptions(params, options);

  const query = useSuspenseQuery(queryOptions, queryClient) as UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * @summary Get ratings for a master
 */
export const getMasterRatings = (
  masterId: string,
  params: GetMasterRatingsParams,
  signal?: AbortSignal,
) => customClient<GetMasterRatingsResponsePagedResponse>(
  {
    url: `/api/v1/ratings/master/${masterId}`,
    method: 'GET',
    params,
    signal,
  },
);

export const getGetMasterRatingsQueryKey = (
  masterId?: string,
  params?: GetMasterRatingsParams,
) => [`/api/v1/ratings/master/${masterId}`, ...(params ? [params] : [])] as const;

export const getGetMasterRatingsQueryOptions = <TData = Awaited<ReturnType<typeof getMasterRatings>>, TError = ValidationProblemDetails>(masterId: string,
  params: GetMasterRatingsParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getMasterRatings>>, TError, TData>>, },
) => {
  const { query: queryOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetMasterRatingsQueryKey(masterId, params);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getMasterRatings>>> = ({ signal }) => getMasterRatings(masterId, params, signal);

  return {
    queryKey, queryFn, enabled: !!(masterId), ...queryOptions,
  } as UseQueryOptions<Awaited<ReturnType<typeof getMasterRatings>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type GetMasterRatingsQueryResult = NonNullable<Awaited<ReturnType<typeof getMasterRatings>>>;
export type GetMasterRatingsQueryError = ValidationProblemDetails;

export function useGetMasterRatings<TData = Awaited<ReturnType<typeof getMasterRatings>>, TError = ValidationProblemDetails>(
  masterId: string,
  params: GetMasterRatingsParams, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getMasterRatings>>, TError, TData>> & Pick<
  DefinedInitialDataOptions<
  Awaited<ReturnType<typeof getMasterRatings>>,
  TError,
  Awaited<ReturnType<typeof getMasterRatings>>
  >, 'initialData'
  >, }
  , queryClient?: QueryClient
): DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useGetMasterRatings<TData = Awaited<ReturnType<typeof getMasterRatings>>, TError = ValidationProblemDetails>(
  masterId: string,
  params: GetMasterRatingsParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getMasterRatings>>, TError, TData>> & Pick<
  UndefinedInitialDataOptions<
  Awaited<ReturnType<typeof getMasterRatings>>,
  TError,
  Awaited<ReturnType<typeof getMasterRatings>>
  >, 'initialData'
  >, }
  , queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useGetMasterRatings<TData = Awaited<ReturnType<typeof getMasterRatings>>, TError = ValidationProblemDetails>(
  masterId: string,
  params: GetMasterRatingsParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getMasterRatings>>, TError, TData>>, }
  , queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
/**
 * @summary Get ratings for a master
 */

export function useGetMasterRatings<TData = Awaited<ReturnType<typeof getMasterRatings>>, TError = ValidationProblemDetails>(
  masterId: string,
  params: GetMasterRatingsParams,
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getMasterRatings>>, TError, TData>>, },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {
  const queryOptions = getGetMasterRatingsQueryOptions(masterId, params, options);

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

export const getGetMasterRatingsSuspenseQueryOptions = <TData = Awaited<ReturnType<typeof getMasterRatings>>, TError = ValidationProblemDetails>(masterId: string,
  params: GetMasterRatingsParams, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getMasterRatings>>, TError, TData>>, },
) => {
  const { query: queryOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetMasterRatingsQueryKey(masterId, params);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getMasterRatings>>> = ({ signal }) => getMasterRatings(masterId, params, signal);

  return { queryKey, queryFn, ...queryOptions } as UseSuspenseQueryOptions<Awaited<ReturnType<typeof getMasterRatings>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type GetMasterRatingsSuspenseQueryResult = NonNullable<Awaited<ReturnType<typeof getMasterRatings>>>;
export type GetMasterRatingsSuspenseQueryError = ValidationProblemDetails;

export function useGetMasterRatingsSuspense<TData = Awaited<ReturnType<typeof getMasterRatings>>, TError = ValidationProblemDetails>(
  masterId: string,
  params: GetMasterRatingsParams, options: { query:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getMasterRatings>>, TError, TData>>, }
  , queryClient?: QueryClient
): UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useGetMasterRatingsSuspense<TData = Awaited<ReturnType<typeof getMasterRatings>>, TError = ValidationProblemDetails>(
  masterId: string,
  params: GetMasterRatingsParams, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getMasterRatings>>, TError, TData>>, }
  , queryClient?: QueryClient
): UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useGetMasterRatingsSuspense<TData = Awaited<ReturnType<typeof getMasterRatings>>, TError = ValidationProblemDetails>(
  masterId: string,
  params: GetMasterRatingsParams, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getMasterRatings>>, TError, TData>>, }
  , queryClient?: QueryClient
): UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
/**
 * @summary Get ratings for a master
 */

export function useGetMasterRatingsSuspense<TData = Awaited<ReturnType<typeof getMasterRatings>>, TError = ValidationProblemDetails>(
  masterId: string,
  params: GetMasterRatingsParams,
  options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getMasterRatings>>, TError, TData>>, },
  queryClient?: QueryClient,
): UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {
  const queryOptions = getGetMasterRatingsSuspenseQueryOptions(masterId, params, options);

  const query = useSuspenseQuery(queryOptions, queryClient) as UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey;

  return query;
}
